\lhead{\textit{CAP\'ITULO \thechapter. Desarrollo}}
\chead{}
\rhead{\thepage}



\chapter{Desarrollo}
\section*{Introducci\'on}

En éste capítulo se muestran las actividades que se realizaron para aplicación del marco metodológico. En la primera sección se hace uso de un \textit{framework} llamado \textit{CloudSim}, se ilustra y describe la arquitectura utilizada para los distintos esquemas de calendarización que posteriormente se implementaron y evaluaron, así como la descripción de algunas partes del código; en la siguiente sección se habla de la mejora de los algoritmos en cuanto a sus características (costo de procesamiento y tiempo de ejecución).



\newpage
\addcontentsline{toc}{section}{Introducci\'on}
\section{Aplicaci\'on del marco metodol\'ogico y de actividades de experimentaci\'on}

En base de los puntos descritos anteriormente en el marco metodol\'ogico se realizar\'on las siguientes actividades:


\subsection{Simulaci\'on del Centro de Datos en la Nube}

 \textit{\textbf{Cloudsim}} es un nuevo, generalizado y extensible \textit{framework} de simulaci\'on, que permite el modelaje, simulaci\'on y experimentaci\'on de infraestructuras emergentes de c\'omputo en la nube y servicios de aplicaci\'on (\citeauthor{calheiros2011cloudsim}, \citeyear{calheiros2011cloudsim}, p. 2).


\setcounter{figure}{2}
\renewcommand\thefigure{\arabic{figure}}
\begin{figure}[h!]
	\centering
	\includegraphics[scale=0.5]{media/imagenuno}
	\caption{Estilo de Trabajo de \textit{CloudSim}, Fuente: Chatterjee et al.}
	\label{fig:TrabajoCloudsim}
	
\end{figure}


Entre los componentes que proporciona dicho \textit{framework} se encuentran los siguientes:

\begin{itemize}
	\item \textit{\textbf{Cloudlet:}} Esta clase modela las aplicaciones de servicio basadas en la nube como pueden ser env\'io de contenido, redes sociales, y flujo de trabajo empresarial (\citeauthor{calheiros2011cloudsim}, \citeyear{calheiros2011cloudsim}, cap. 4).
	\item \textit{ \textbf{Datacenter:}} Esta clase modela el núcleo de los servicios en un nivel de infraestructura \textit{(hardware)} que son ofrecidos por \textit{Cloud Providers (Amazon, Azure, App Engine)}. Estos son encapsulados en un conjunto de \textit{host} que pueden ser homogéneos o heterogéneos con respecto a sus configuraciones de \textit{hardware} (memoria, n\'ucleos, capacidad, y almacenamiento) (\citeauthor{calheiros2011cloudsim}, \citeyear{calheiros2011cloudsim}, cap. 4).
	\item \textit{ \textbf{DatacenterBroker:}} Esta clase modela un \textit{broker}, el cual es responsable de mediar las negociaciones entre el \textit{SaaS} y los \textit{Cloud providers}; y dichas negociaciones son manejadas por los requerimientos \textit{QoS} (\citeauthor{calheiros2011cloudsim}, \citeyear{calheiros2011cloudsim}, cap. 4).
	\item  \textit{\textbf{Host:}} Esta clase modela los recursos f\'isicos como una computadora o un servidor de almacenamiento (\citeauthor{calheiros2011cloudsim}, \citeyear{calheiros2011cloudsim}, cap. 4).
	\item  \textit{\textbf{Vm:}} Esta clase modela una M\'aquina Virtual \textit{(VM)}, la cual es administrada y hosteada por un componente \textit{host} en la nube. Cada \textit{VM} tiene acceso a un componente que almacena las siguientes características relacionadas a una \textit{VM}: memoria accesible, procesador, tamaño de almacenamiento (\citeauthor{calheiros2011cloudsim}, \citeyear{calheiros2011cloudsim}, cap. 4).
\end{itemize}


\newpage

\subsection{Implementaci\'on y evaluación de los Algoritmos}

Existen varios algoritmos para calendarizar los trabajos en el c\'omputo en la nube. La mayor ventaja de estos algoritmos es obtener el mayor rendimiento. Los principales ejemplos de algoritmos de calendarizaci\'on son: \textit{FCFS, Round Robin, Min-Min, Max-Min y algoritmos de metaheurísticas}  (\citeauthor{shimpy2014different}, \citeyear{shimpy2014different}, p. 1).



De los algoritmos mencionados anteriormente, se presentan los siguientes:


\begin{itemize}
	\item \textit{\textbf{FCFS:}} Ejecuta las tareas en orden de llegada, es decir, el primero en llegar es el primero en ser atendido.
	\item \textit{\textbf{Min-Min:}} Selecciona las tareas m\'as pequeñas para ser ejecutadas primero.
	\item  \textit{\textbf{Max-Min:}} Selecciona las tareas m\'as grandes para ser ejecutadas primero.
	\item \textit{\textbf{Round Robin:}} Ejecuta las tareas en orden de llegada, si el número de tarea actual es mayor al número de máquinas virtuales reinicia el ciclo de asignación hacía la primera máquina virtual.
\end{itemize}

En un entorno de trabajo normal, la forma descrita anteriormente para los algoritmos de \textit{FCFS, Min-Min, Max-Min y Round Robin} lo podemos apreciar de la siguiente manera, Figura (\ref{fig:cuatro}):


\setcounter{figure}{3}
\renewcommand\thefigure{\arabic{figure}}
\begin{figure}[H]
	\centering
	\includegraphics[scale=0.4]{media/NuevoEsquema}
	\caption{Esquema de trabajo de algoritmos de calendarizaci\'on, Fuente: Elaboraci\'on propia.}
	\label{fig:cuatro}
\end{figure}


Sin embargo en un entorno en la nube, al ser m\'ultiples m\'aquinas virtuales alojadas en distintos \textit{hosts}, que a su vez pueden formar parte de uno o m\'as \textit{datacenters}, dicho esquema tiene que ser modificado para poder adoptar un estilo de trabajo similar al proporcionado por el \textit{framework}, por lo que los resultados quedan de la distinta manera:


\setcounter{figure}{4}
\renewcommand\thefigure{\arabic{figure}}
\begin{figure}[h!]
	\centering
	\includegraphics[scale=0.4]{media/imagentres}
	\caption{Arquitectura FCFS para un entorno en la nube. Fuente: Elaboraci\'on propia.}
	\label{fig:fcfs}
\end{figure}

Como podemos apreciar en el diagrama (Figura \ref{fig:fcfs}), podemos tener \emph{m} usuarios ejecutando \emph{n} tareas, sin embargo la asignaci\'on de m\'aquinas virtuales va dependiendo del orden de llegada de dichas tareas, y quien se encarga de repartir las tareas es el \textit{datacenterBroker}. \\

De manera similar tenemos los siguientes algoritmos \textit{Min-Min} (Figura \ref{fig:min}) y \textit{Max-Min} (Figura \ref{fig:max}):

\newpage

\setcounter{figure}{5}
\renewcommand\thefigure{\arabic{figure}}
\begin{figure}[h!]
	\centering
	\includegraphics[scale=0.5]{media/imagencinco}
	\caption{Arquitectura de \textit{Min-Min} para un entorno en la nube. Fuente: Elaboraci\'on propia.}
	\label{fig:min}
\end{figure}

Para el algoritmo de \textit{Min-Min} (Figura \ref{fig:min}), obtenemos la lista de tareas a partir de la informaci\'on de ellas, procedemos a ordenarlas de menor a mayor tama\~no, asignando la de menor tama\~no en la primera m\'aquina virtual, la siguiente tarea, de acuerdo al tama\~no, pasa a la segunda m\'aquina y as\'i sucesivamente.

\newpage
\setcounter{figure}{6}
\renewcommand\thefigure{\arabic{figure}}
\begin{figure}[h!]
	\centering
	\includegraphics[scale=0.5]{media/imagencuatro}
	\caption{Arquitectura de \textit{Max-Min} para un entorno en la nube. Fuente: Elaboraci\'on propia.}
	\label{fig:max}
\end{figure}

En la figura (\ref{fig:max}) tenemos el algoritmo de \textit{Max-Min}, el cual ordena la lista de tareas de mayor a menor tama\~no antes de asignarlas a las m\'aquinas virtuales, una vez ordenada dicha lista procede a asignar la tarea m\'as grande en la primera m\'aquina, la siguiente en la segunda y as\'i sucesivamente hasta terminar la asignaci\'on de las tareas.

\newpage
\renewcommand\thefigure{\arabic{figure}}
\begin{figure}[h!]
	\centering
	\includegraphics[scale=0.4]{media/RRAlgorithm}
	\caption{Arquitectura de \textit{Round Robin} para un entorno en la nube. Fuente: Elaboración propia.}
	\label{fig:RRAlgorithm}
\end{figure}

Como podemos apreciar en la figura (\ref{fig:RRAlgorithm}), las tareas se van ejecutando de manera que llegan pero al momento de ser mayor el número de tarea la asigna en la máquina virtual principal, esta operación de asignación la podemos expresar de la siguiente manera: $$C_n \rightarrow Vm_{n \% m}$$ donde $C_n$ representa la $n$-ésima tarea y $m$ es el número total de máquinas virtuales.

\newpage
A continuaci\'on se muestran algunas capturas del c\'odigo para la implementaci\'on de los primeros algoritmos en el centro de datos:


\subsection*{Configuración de Elementos del \textit{Datacenter} y \textit{DatacenterBrokers} para Algoritmos de Calendarización}
\addcontentsline{toc}{subsection}{Configuración de Elementos del Datacenter y DatacenterBrokers para Algoritmos de Calendarización}

\setcounter{figure}{8}
\renewcommand\thefigure{\arabic{figure}}
\begin{figure}[h!]
	\centering
	\includegraphics[scale=0.5]{media/caracteristicas_datacenter}
	\caption{Características del \textit{datacenter}. Fuente: Elaboración propia.}
	\label{fig:DCar}
\end{figure}


Como primer paso,  debemos de configurar las caracter\'isticas que tendrá nuestro \textit{datacenter}, para eso tenemos que definir la arquitectura, el tipo de sistema operativo, costos de utilizaci\'on de memoria, almacenamiento y ancho de banda, entre otros (Figura \ref{fig:DCar}).

\newpage

\setcounter{figure}{9}
\renewcommand\thefigure{\arabic{figure}}
\begin{figure}[h!]
	\centering
	\includegraphics[scale=0.5]{media/caracteristicas_host}
	\caption{Características del \textit{Host}. Fuente: Elaboración propia.}
	\label{fig:HCar}
	
\end{figure}

De igual manera tenemos que asignar las caracter\'isticas que tendr\'a cada \textit{host} dentro del \textit{datacenter} (Figura \ref{fig:HCar}), tales como el n\'umero de procesadores, n\'umero de instrucciones por segundo, memoria RAM, capacidad de almacenamiento y el ancho de banda.

\newpage

\setcounter{figure}{10}
\renewcommand\thefigure{\arabic{figure}}
\begin{figure}[h!]
	\centering
	\includegraphics[scale=0.3]{media/creacion_vm}
	\caption{Características de las máquinas virtuales. Fuente: Elaboración propia.}
	\label{fig:VCar}
\end{figure}


Continuando con las configuraciones, en la Figura (\ref{fig:VCar}) se muestran las caracter\'isticas utilizadas en las m\'aquinas virtuales, las cuales son: tamaño de la imagen, memoria RAM virtual, n\'umero de instrucciones por segundo, ancho de banda y el n\'umero de procesadores.


\setcounter{figure}{11}
\renewcommand\thefigure{\arabic{figure}}
\begin{figure}[h!]
	\centering
	\includegraphics[scale=0.5]{media/creacion_cloudlet}
	\caption{Características de las Tareas \textit{(cloudlets)}. Fuente: Elaboración propia.}
	\label{fig:TCar}
\end{figure} 





Adem\'as de los recursos, se debe de hacer la configuraci\'on de las tareas a simular (Figura \ref{fig:TCar}), teniendo como par\'ametros el tamaño de la tarea, tamaño de entrada y de salida, as\'i como el número de procesadores que ocupar\'a la tarea, esto \'ultimo refleja la complejidad de la tarea.

\subsection*{\textit{DatacenterBrokers} para Algoritmos de Calendarización}
\addcontentsline{toc}{subsection}{DatacenterBrokers para Algoritmos de Calendarización}

Partiendo del Esquema que se muestra en la figura (\ref{fig:TrabajoCloudsim}), el trabajo presentado se lleva a cabo en la parte de Tareas (\textit{cloudlets}) y M\'aquinas Virtuales (\textit{Virtual Machines}) ya que se pretende mejorar un algoritmo de calendarizaci\'on de tareas.
Para ello seg\'un muestra el diagrama, el encargado de asignar cada tarea en una m\'aquina virtual es el \textit{datacenter broker}, el cual toma la lista de tareas as\'i como la lista de m\'aquinas virtuales, y de acuerdo a alg\'un algoritmo realiza la asignaci\'on de cada una de las tareas en las distintas m\'aquinas virtuales disponibles.

\setcounter{figure}{12}
\renewcommand\thefigure{\arabic{figure}}
\begin{figure}[h!]
	\centering
	\includegraphics[scale=0.5]{media/FCFS_broker}
	\caption{\textit{FCFS Broker}. Fuente: Elaboración propia.}
	\label{fig:fcfsBroker}
\end{figure}

La Figura (\ref{fig:fcfsBroker}) muestra el algoritmo de \textit{FCFS}, recorre la lista de tareas y la asigna en la m\'aquina virtual correspondiente, calculando la tarea actual $i$ en la m\'aquina virtual \textbf{$i\%reqVms$} donde \textbf{$reqVms$} es el n\'umero de m\'aquinas virtuales.

\setcounter{figure}{13}
\renewcommand\thefigure{\arabic{figure}}
\begin{figure}[h!]
	\centering
	\includegraphics[scale=0.5]{media/minmin_broker}
	\caption{\textit{Min-Min Broker}. Fuente: Elaboración propia.}
	\label{fig:minminBroker}
\end{figure}

\newpage

En la Figura (\ref{fig:minminBroker}) tenemos la implementaci\'on del algoritmo \textit{Min-Min} en el cual podemos apreciar el ordenamiento de la lista antes de pasar a  la asignaci\'on de las m\'aquinas virtuales.

\newpage
\setcounter{figure}{14}
\renewcommand\thefigure{\arabic{figure}}
\begin{figure}[h!]
	\centering
	\includegraphics[scale=0.5]{media/maxmin_broker}
	\caption{\textit{Max-min Broker}. Fuente: Elaboración propia.}
	\label{fig:maxminBroker}
\end{figure}

En la Figura (\ref{fig:maxminBroker}) observamos la implementaci\'on del algoritmo de \textit{Max-Min} el cual hace un ordenamiento de mayor a menor, v\'ease la funci\'on \textbf{\textit{revert}} utilizada, la cual se explicar\'a m\'as adelante.

\newpage


\setcounter{figure}{15}
\renewcommand\thefigure{\arabic{figure}}
\begin{figure}[h!]
	\centering
	\includegraphics[scale=0.5]{media/ordenamientos}
	\caption{\textit{Algoritmos de ordenamientos}. Fuente: Elaboración propia.}
	\label{fig:sortRevert}
\end{figure}

En la Figura (\ref{fig:sortRevert}) tenemos la implementaci\'on de los m\'etodos de ordenamiento utilizados, el \textbf{sort} utilizado para ordenar las tareas de menor a mayor de acuerdo al tamaño y el \textbf{revert} de forma inversa.

\newpage
\setcounter{figure}{16}
\renewcommand\thefigure{\arabic{figure}}
\begin{figure}[h!]
	\centering
	\includegraphics[scale=0.4]{media/RRBroker}
	\caption{\textit{Round Robin Broker}. Fuente: Elaboración propia.}
	\label{fig:RRBroker}
\end{figure}

En la Figura (\ref{fig:RRBroker}) se muestra la implementación del \textit{Broker} para el algoritmo de \textit{Round Robin}, en el cual se hace una variación con respecto al \textit{Quantum} de tiempo hacia disponibilidad de ancho de banda de la máquina virtual.


\subsection{Mejorar el costo de procesamiento y el tiempo de ejecución}

El objetivo de éste proyecto es minimizar el tiempo de ejecución y el costo de procesamiento de acuerdo a los recursos heterogéneos del centro de datos. Para ello se hará la  implementación de una \textit{meta-heurística} con un método llamado Optimización por Enjambre de Partículas \textit{PSO} (\textit{Particle Swarm Optimization}).\\

Optimización por Enjambre de Partículas (\textit{PSO}) es una técnica de optimización basada en la búsqueda de un óptimo global, introducida por Kennedy and Eberhart (\cite{pandey2010}). 

Se eligió  \textit{PSO} debido al concepto simple que tiene (\cite{poli2007}),  la implementación requiere de simples operaciones matemáticas que en términos de computación no consume memoria  y la velocidad de convergencia es relativamente rápida dependiendo del número de partículas (\cite{eberhart1995}).\\ 
Está claro que como toda \textit{metaheurística, PSO} no garantiza la obtención de una solución óptima en todos los casos (\cite{osman2012}).

\subsection*{Algoritmo \textit{PSO} y un ambiente en la nube}
\addcontentsline{toc}{subsection}{Algoritmo PSO y un ambiente en la nube}
\textit{PSO} permite optimizar un problema en base a una población de soluciones candidatas, que llevan el término \textit{“partículas”}, dichas partículas se mueven en un espacio de búsqueda (tienen en cuenta dos aspectos; la posición y la velocidad). Cada una realiza un movimiento influido por su mejor posición local hasta ése momento y por las mejores posiciones globales encontradas en todo el enjambre mientras recorren el espacio de búsqueda (\cite{poli2007}).

Una solución potencial es representada en \textit{PSO} por un vector (partícula). Cada partícula \textit{i} tiene la misma dimensión \textit{n} y es representada de la siguiente manera (\cite{pandey2010}): $X(i) = (x_{(i,1)},x_{(i,2)},...,x_{(i,n)})  $.

Para la simulación en \textit{CloudSim} éstas partículas serán las tareas en el centro de datos, $ = \{T_1 , T_2 , ... T_n\}  $.

%De igual manera las dependencias de los datos es representado por $E$,  que es, $f_j,k = (T_j,T_k) \in E$, en otras palabras $E$ es el dato producido por $T_j$ y consumido por $T_k$. 

En el centro de datos se tiene un conjunto de máquinas virtuales $VM = \{1,..,j\}$, y un conjunto de tareas $T = \{1,...,k\}$. Entonces se asume que el \textit{"promedio"} del tiempo de procesamiento de una tarea $T_k$ en la máquina virtual $VM_j$ para un tamaño de tarea conocido.\\




\begin{algorithm} 
	\begin{algorithmic}[1]
		\State El número de partículas será igual al número de tareas en $ \{ t_i \} \in T $.
		\State Se inicializa la posición de las partículas aleatoriamente de $VM = 1,...,j $ y con velocidad aleatoria $v_i$.
		\State Para cada partícula, calcular $fitness value$.
		\State Si $fitness value$ es mejor que el anterior $pbest$, igualar $fitness value$ como el nuevo $pbest$.
		\State Seleccionar la mejor partícula como $gbest$.
		\State Para todas las partículas, calcular la velocidad y actualizar su posición.
		\State Si no se alcanza el máximo número de iteraciones, repetir el paso 3.
		
	\end{algorithmic} 
	\caption{Algoritmo PSO en la simulación}
	\label{alg:PSO}
\end{algorithm}


En el algoritmo 1 se muestran los pasos del PSO. Inicia con una inicialización aleatoria de la posición y velocidad de las partículas. Para la simulación las partículas serán las tareas en el centro de datos.
El valor asignado a la dimensión de las partículas son los índices de los recursos (Máquinas Virtuales). Por lo tanto cada tarea representa un mapeo de una tarea en todas las máquinas virtuales. Entonces la dimensión de una partícula depende del número de máquinas virtuales.
Para cada partícula se calcula un $fitnessvalue$ que es el óptimo local al nivel de partícula se evalúa y se actualiza. 
Después se evalúa la mejor partícula como $gbest$ que sería el óptimo del enjambre.
Se delimita un número $m$, mientras no se llegue al límite la iteración continua. Esto para no entrar a un ciclo que nunca termina, ya que PSO  no garantiza la obtención de una solución óptima en todos los casos (\cite{osman2012}).

%ver la seccion anexo